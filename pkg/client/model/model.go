// Package model provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package model

import (
	"encoding/json"
	"fmt"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for CheckConfigStaticIpInfoStatic.
const (
	CheckConfigStaticIpInfoStaticError CheckConfigStaticIpInfoStatic = "error"

	CheckConfigStaticIpInfoStaticNo CheckConfigStaticIpInfoStatic = "no"

	CheckConfigStaticIpInfoStaticYes CheckConfigStaticIpInfoStatic = "yes"
)

// Defines values for DNSConfigBlockingMode.
const (
	DNSConfigBlockingModeCustomIp DNSConfigBlockingMode = "custom_ip"

	DNSConfigBlockingModeDefault DNSConfigBlockingMode = "default"

	DNSConfigBlockingModeNullIp DNSConfigBlockingMode = "null_ip"

	DNSConfigBlockingModeNxdomain DNSConfigBlockingMode = "nxdomain"

	DNSConfigBlockingModeRefused DNSConfigBlockingMode = "refused"
)

// Defines values for DhcpSearchResultOtherServerFound.
const (
	DhcpSearchResultOtherServerFoundError DhcpSearchResultOtherServerFound = "error"

	DhcpSearchResultOtherServerFoundNo DhcpSearchResultOtherServerFound = "no"

	DhcpSearchResultOtherServerFoundYes DhcpSearchResultOtherServerFound = "yes"
)

// Defines values for DhcpSearchResultStaticIPStatic.
const (
	DhcpSearchResultStaticIPStaticError DhcpSearchResultStaticIPStatic = "error"

	DhcpSearchResultStaticIPStaticNo DhcpSearchResultStaticIPStatic = "no"

	DhcpSearchResultStaticIPStaticYes DhcpSearchResultStaticIPStatic = "yes"
)

// Defines values for FilterCheckHostResponseReason.
const (
	FilterCheckHostResponseReasonFilteredBlackList FilterCheckHostResponseReason = "FilteredBlackList"

	FilterCheckHostResponseReasonFilteredBlockedService FilterCheckHostResponseReason = "FilteredBlockedService"

	FilterCheckHostResponseReasonFilteredInvalid FilterCheckHostResponseReason = "FilteredInvalid"

	FilterCheckHostResponseReasonFilteredParental FilterCheckHostResponseReason = "FilteredParental"

	FilterCheckHostResponseReasonFilteredSafeBrowsing FilterCheckHostResponseReason = "FilteredSafeBrowsing"

	FilterCheckHostResponseReasonFilteredSafeSearch FilterCheckHostResponseReason = "FilteredSafeSearch"

	FilterCheckHostResponseReasonNotFilteredError FilterCheckHostResponseReason = "NotFilteredError"

	FilterCheckHostResponseReasonNotFilteredNotFound FilterCheckHostResponseReason = "NotFilteredNotFound"

	FilterCheckHostResponseReasonNotFilteredWhiteList FilterCheckHostResponseReason = "NotFilteredWhiteList"

	FilterCheckHostResponseReasonRewrite FilterCheckHostResponseReason = "Rewrite"

	FilterCheckHostResponseReasonRewriteEtcHosts FilterCheckHostResponseReason = "RewriteEtcHosts"

	FilterCheckHostResponseReasonRewriteRule FilterCheckHostResponseReason = "RewriteRule"
)

// Defines values for QueryLogConfigInterval.
const (
	QueryLogConfigIntervalN025 QueryLogConfigInterval = 0.25

	QueryLogConfigIntervalN1 QueryLogConfigInterval = 1

	QueryLogConfigIntervalN30 QueryLogConfigInterval = 30

	QueryLogConfigIntervalN7 QueryLogConfigInterval = 7

	QueryLogConfigIntervalN90 QueryLogConfigInterval = 90
)

// Defines values for QueryLogItemReason.
const (
	QueryLogItemReasonFilteredBlackList QueryLogItemReason = "FilteredBlackList"

	QueryLogItemReasonFilteredBlockedService QueryLogItemReason = "FilteredBlockedService"

	QueryLogItemReasonFilteredInvalid QueryLogItemReason = "FilteredInvalid"

	QueryLogItemReasonFilteredParental QueryLogItemReason = "FilteredParental"

	QueryLogItemReasonFilteredSafeBrowsing QueryLogItemReason = "FilteredSafeBrowsing"

	QueryLogItemReasonFilteredSafeSearch QueryLogItemReason = "FilteredSafeSearch"

	QueryLogItemReasonNotFilteredError QueryLogItemReason = "NotFilteredError"

	QueryLogItemReasonNotFilteredNotFound QueryLogItemReason = "NotFilteredNotFound"

	QueryLogItemReasonNotFilteredWhiteList QueryLogItemReason = "NotFilteredWhiteList"

	QueryLogItemReasonRewrite QueryLogItemReason = "Rewrite"

	QueryLogItemReasonRewriteEtcHosts QueryLogItemReason = "RewriteEtcHosts"

	QueryLogItemReasonRewriteRule QueryLogItemReason = "RewriteRule"
)

// Defines values for StatsTimeUnits.
const (
	StatsTimeUnitsDays StatsTimeUnits = "days"

	StatsTimeUnitsHours StatsTimeUnits = "hours"
)

// Defines values for StatsConfigInterval.
const (
	StatsConfigIntervalN0 StatsConfigInterval = 0

	StatsConfigIntervalN1 StatsConfigInterval = 1

	StatsConfigIntervalN30 StatsConfigInterval = 30

	StatsConfigIntervalN7 StatsConfigInterval = 7

	StatsConfigIntervalN90 StatsConfigInterval = 90
)

// Defines values for TlsConfigKeyType.
const (
	TlsConfigKeyTypeECDSA TlsConfigKeyType = "ECDSA"

	TlsConfigKeyTypeRSA TlsConfigKeyType = "RSA"
)

// Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessList struct {
	// The allowlist of clients: IP addresses, CIDRs, or ClientIDs.
	AllowedClients *[]string `json:"allowed_clients,omitempty"`

	// The blocklist of hosts.
	BlockedHosts *[]string `json:"blocked_hosts,omitempty"`

	// The blocklist of clients: IP addresses, CIDRs, or ClientIDs.
	DisallowedClients *[]string `json:"disallowed_clients,omitempty"`
}

// Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessListResponse AccessList

// Client and host access list.  Each of the lists should contain only unique elements.  In addition, allowed and disallowed lists cannot contain the same elements.
type AccessSetRequest AccessList

// /add_url request data
type AddUrlRequest struct {
	Name *string `json:"name,omitempty"`

	// URL or an absolute path to the file containing filtering rules.
	Url       *string `json:"url,omitempty"`
	Whitelist *bool   `json:"whitelist,omitempty"`
}

// Port information
type AddressInfo struct {
	Ip   string `json:"ip"`
	Port uint16 `json:"port"`
}

// Port information
type AddressInfoBeta struct {
	Ip   []string `json:"ip"`
	Port uint16   `json:"port"`
}

// AdGuard Home addresses configuration
type AddressesInfo struct {
	DnsPort uint16 `json:"dns_port"`

	// Network interfaces dictionary, keys are interface names.
	Interfaces NetInterfaces `json:"interfaces"`
	Version    string        `json:"version"`
	WebPort    uint16        `json:"web_port"`
}

// AdGuard Home addresses configuration
type AddressesInfoBeta struct {
	DnsPort uint16 `json:"dns_port"`

	// Network interfaces dictionary, keys are interface names.
	Interfaces []NetInterface `json:"interfaces"`
	WebPort    uint16         `json:"web_port"`
}

// BlockedServicesArray defines model for BlockedServicesArray.
type BlockedServicesArray []string

// Configuration to be checked
type CheckConfigRequest struct {
	Dns         *CheckConfigRequestInfo `json:"dns,omitempty"`
	SetStaticIp *bool                   `json:"set_static_ip,omitempty"`
	Web         *CheckConfigRequestInfo `json:"web,omitempty"`
}

// Configuration to be checked
type CheckConfigRequestBeta struct {
	Dns         *CheckConfigRequestInfoBeta `json:"dns,omitempty"`
	SetStaticIp *bool                       `json:"set_static_ip,omitempty"`
	Web         *CheckConfigRequestInfoBeta `json:"web,omitempty"`
}

// CheckConfigRequestInfo defines model for CheckConfigRequestInfo.
type CheckConfigRequestInfo struct {
	Autofix *bool   `json:"autofix,omitempty"`
	Ip      *string `json:"ip,omitempty"`
	Port    *uint16 `json:"port,omitempty"`
}

// CheckConfigRequestInfoBeta defines model for CheckConfigRequestInfoBeta.
type CheckConfigRequestInfoBeta struct {
	Autofix *bool     `json:"autofix,omitempty"`
	Ip      *[]string `json:"ip,omitempty"`
	Port    *uint16   `json:"port,omitempty"`
}

// CheckConfigResponse defines model for CheckConfigResponse.
type CheckConfigResponse struct {
	Dns      CheckConfigResponseInfo `json:"dns"`
	StaticIp CheckConfigStaticIpInfo `json:"static_ip"`
	Web      CheckConfigResponseInfo `json:"web"`
}

// CheckConfigResponseInfo defines model for CheckConfigResponseInfo.
type CheckConfigResponseInfo struct {
	CanAutofix bool   `json:"can_autofix"`
	Status     string `json:"status"`
}

// CheckConfigStaticIpInfo defines model for CheckConfigStaticIpInfo.
type CheckConfigStaticIpInfo struct {
	// Error text. Set if static=error
	Error *string `json:"error,omitempty"`

	// Current dynamic IP address. Set if static=no
	Ip *string `json:"ip,omitempty"`

	// Can be: yes, no, error
	Static *CheckConfigStaticIpInfoStatic `json:"static,omitempty"`
}

// Can be: yes, no, error
type CheckConfigStaticIpInfoStatic string

// Client information.
type Client struct {
	BlockedServices  *[]string `json:"blocked_services,omitempty"`
	FilteringEnabled *bool     `json:"filtering_enabled,omitempty"`

	// IP, CIDR, MAC, or ClientID.
	Ids *[]string `json:"ids,omitempty"`

	// Name
	Name                     *string   `json:"name,omitempty"`
	ParentalEnabled          *bool     `json:"parental_enabled,omitempty"`
	SafebrowsingEnabled      *bool     `json:"safebrowsing_enabled,omitempty"`
	SafesearchEnabled        *bool     `json:"safesearch_enabled,omitempty"`
	Tags                     *[]string `json:"tags,omitempty"`
	Upstreams                *[]string `json:"upstreams,omitempty"`
	UseGlobalBlockedServices *bool     `json:"use_global_blocked_services,omitempty"`
	UseGlobalSettings        *bool     `json:"use_global_settings,omitempty"`
}

// Auto-Client information
type ClientAuto struct {
	// IP address
	Ip *string `json:"ip,omitempty"`

	// Name
	Name *string `json:"name,omitempty"`

	// The source of this information
	Source    *string    `json:"source,omitempty"`
	WhoisInfo *WhoisInfo `json:"whois_info,omitempty"`
}

// Client delete request
type ClientDelete struct {
	Name *string `json:"name,omitempty"`
}

// Client information.
type ClientFindSubEntry struct {
	BlockedServices *[]string `json:"blocked_services,omitempty"`

	// Whether the client's IP is blocked or not.
	Disallowed *bool `json:"disallowed,omitempty"`

	// The rule due to which the client is disallowed.  If disallowed is set to true, and this string is empty, then the client IP is disallowed by the "allowed IP list", that is it is not included in the allowed list.
	DisallowedRule   *string `json:"disallowed_rule,omitempty"`
	FilteringEnabled *bool   `json:"filtering_enabled,omitempty"`

	// IP, CIDR, MAC, or ClientID.
	Ids *[]string `json:"ids,omitempty"`

	// Name
	Name                     *string    `json:"name,omitempty"`
	ParentalEnabled          *bool      `json:"parental_enabled,omitempty"`
	SafebrowsingEnabled      *bool      `json:"safebrowsing_enabled,omitempty"`
	SafesearchEnabled        *bool      `json:"safesearch_enabled,omitempty"`
	Upstreams                *[]string  `json:"upstreams,omitempty"`
	UseGlobalBlockedServices *bool      `json:"use_global_blocked_services,omitempty"`
	UseGlobalSettings        *bool      `json:"use_global_settings,omitempty"`
	WhoisInfo                *WhoisInfo `json:"whois_info,omitempty"`
}

// Client update request
type ClientUpdate struct {
	// Client information.
	Data *Client `json:"data,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Clients defines model for Clients.
type Clients struct {
	// Auto-Clients array
	AutoClients *ClientsAutoArray `json:"auto_clients,omitempty"`

	// Clients array
	Clients       *ClientsArray `json:"clients,omitempty"`
	SupportedTags *[]string     `json:"supported_tags,omitempty"`
}

// Clients array
type ClientsArray []Client

// Auto-Clients array
type ClientsAutoArray []ClientAuto

// ClientsFindEntry defines model for ClientsFindEntry.
type ClientsFindEntry struct {
	AdditionalProperties map[string]ClientFindSubEntry `json:"-"`
}

// Client search results.
type ClientsFindResponse []ClientsFindEntry

// Query log configuration
type DNSConfig struct {
	BlockingIpv4 *string                `json:"blocking_ipv4,omitempty"`
	BlockingIpv6 *string                `json:"blocking_ipv6,omitempty"`
	BlockingMode *DNSConfigBlockingMode `json:"blocking_mode,omitempty"`

	// Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
	BootstrapDns    *[]string `json:"bootstrap_dns,omitempty"`
	CacheOptimistic *bool     `json:"cache_optimistic,omitempty"`
	CacheSize       *int      `json:"cache_size,omitempty"`
	CacheTtlMax     *int      `json:"cache_ttl_max,omitempty"`
	CacheTtlMin     *int      `json:"cache_ttl_min,omitempty"`
	DhcpAvailable   *bool     `json:"dhcp_available,omitempty"`
	DisableIpv6     *bool     `json:"disable_ipv6,omitempty"`
	DnssecEnabled   *bool     `json:"dnssec_enabled,omitempty"`
	EdnsCsEnabled   *bool     `json:"edns_cs_enabled,omitempty"`

	// Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	LocalPtrUpstreams *[]string `json:"local_ptr_upstreams,omitempty"`
	ProtectionEnabled *bool     `json:"protection_enabled,omitempty"`
	Ratelimit         *int      `json:"ratelimit,omitempty"`
	ResolveClients    *bool     `json:"resolve_clients,omitempty"`

	// Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	UpstreamDns            *[]string    `json:"upstream_dns,omitempty"`
	UpstreamDnsFile        *string      `json:"upstream_dns_file,omitempty"`
	UpstreamMode           *interface{} `json:"upstream_mode,omitempty"`
	UsePrivatePtrResolvers *bool        `json:"use_private_ptr_resolvers,omitempty"`
}

// DNSConfigBlockingMode defines model for DNSConfig.BlockingMode.
type DNSConfigBlockingMode string

// DhcpConfig defines model for DhcpConfig.
type DhcpConfig struct {
	Enabled       *bool         `json:"enabled,omitempty"`
	InterfaceName *string       `json:"interface_name,omitempty"`
	V4            *DhcpConfigV4 `json:"v4,omitempty"`
	V6            *DhcpConfigV6 `json:"v6,omitempty"`
}

// DhcpConfigV4 defines model for DhcpConfigV4.
type DhcpConfigV4 struct {
	GatewayIp     *string `json:"gateway_ip,omitempty"`
	LeaseDuration *int    `json:"lease_duration,omitempty"`
	RangeEnd      *string `json:"range_end,omitempty"`
	RangeStart    *string `json:"range_start,omitempty"`
	SubnetMask    *string `json:"subnet_mask,omitempty"`
}

// DhcpConfigV6 defines model for DhcpConfigV6.
type DhcpConfigV6 struct {
	LeaseDuration *int    `json:"lease_duration,omitempty"`
	RangeStart    *string `json:"range_start,omitempty"`
}

// DHCP lease information
type DhcpLease struct {
	Expires  string `json:"expires"`
	Hostname string `json:"hostname"`
	Ip       string `json:"ip"`
	Mac      string `json:"mac"`
}

// Information about a DHCP server discovered in the current network.
type DhcpSearchResult struct {
	V4 *DhcpSearchV4 `json:"v4,omitempty"`
	V6 *DhcpSearchV6 `json:"v6,omitempty"`
}

// DhcpSearchResultOtherServer defines model for DhcpSearchResultOtherServer.
type DhcpSearchResultOtherServer struct {
	// Set if found=error
	Error *string `json:"error,omitempty"`

	// The result of searching the other DHCP server.
	Found *DhcpSearchResultOtherServerFound `json:"found,omitempty"`
}

// The result of searching the other DHCP server.
type DhcpSearchResultOtherServerFound string

// DhcpSearchResultStaticIP defines model for DhcpSearchResultStaticIP.
type DhcpSearchResultStaticIP struct {
	// Set if static=no
	Ip *string `json:"ip,omitempty"`

	// The result of determining static IP address.
	Static *DhcpSearchResultStaticIPStatic `json:"static,omitempty"`
}

// The result of determining static IP address.
type DhcpSearchResultStaticIPStatic string

// DhcpSearchV4 defines model for DhcpSearchV4.
type DhcpSearchV4 struct {
	OtherServer *DhcpSearchResultOtherServer `json:"other_server,omitempty"`
	StaticIp    *DhcpSearchResultStaticIP    `json:"static_ip,omitempty"`
}

// DhcpSearchV6 defines model for DhcpSearchV6.
type DhcpSearchV6 struct {
	OtherServer *DhcpSearchResultOtherServer `json:"other_server,omitempty"`
}

// DHCP static lease information
type DhcpStaticLease struct {
	Hostname string `json:"hostname"`
	Ip       string `json:"ip"`
	Mac      string `json:"mac"`
}

// Built-in DHCP server configuration and status
type DhcpStatus struct {
	Enabled       *bool              `json:"enabled,omitempty"`
	InterfaceName *string            `json:"interface_name,omitempty"`
	Leases        []DhcpLease        `json:"leases"`
	StaticLeases  *[]DhcpStaticLease `json:"static_leases,omitempty"`
	V4            *DhcpConfigV4      `json:"v4,omitempty"`
	V6            *DhcpConfigV6      `json:"v6,omitempty"`
}

// DNS answer section
type DnsAnswer struct {
	Ttl   *uint32 `json:"ttl,omitempty"`
	Type  *string `json:"type,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DNS question section
type DnsQuestion struct {
	Class       *string `json:"class,omitempty"`
	Name        *string `json:"name,omitempty"`
	Type        *string `json:"type,omitempty"`
	UnicodeName *string `json:"unicode_name,omitempty"`
}

// A generic JSON error response.
type Error struct {
	// The error message, an opaque string.
	Message *string `json:"message,omitempty"`
}

// Filter subscription info
type Filter struct {
	Enabled    bool   `json:"enabled"`
	Id         int64  `json:"id"`
	Name       string `json:"name"`
	RulesCount uint32 `json:"rules_count"`
	Url        string `json:"url"`
}

// Check Host Result
type FilterCheckHostResponse struct {
	// Set if reason=Rewrite
	Cname *string `json:"cname,omitempty"`

	// In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	// Deprecated: use `rules[*].filter_list_id` instead.
	FilterId *int `json:"filter_id,omitempty"`

	// Set if reason=Rewrite
	IpAddrs *[]string `json:"ip_addrs,omitempty"`

	// Request filtering status.
	Reason *FilterCheckHostResponseReason `json:"reason,omitempty"`

	// Filtering rule applied to the request (if any).
	// Deprecated: use `rules[*].text` instead.
	Rule *string `json:"rule,omitempty"`

	// Applied rules.
	Rules *[]ResultRule `json:"rules,omitempty"`

	// Set if reason=FilteredBlockedService
	ServiceName *string `json:"service_name,omitempty"`
}

// Request filtering status.
type FilterCheckHostResponseReason string

// Filtering settings
type FilterConfig struct {
	Enabled  *bool `json:"enabled,omitempty"`
	Interval *int  `json:"interval,omitempty"`
}

// Refresh Filters request data
type FilterRefreshRequest struct {
	Whitelist *bool `json:"whitelist,omitempty"`
}

// /filtering/refresh response data
type FilterRefreshResponse struct {
	Updated *int `json:"updated,omitempty"`
}

// Filtering URL settings
type FilterSetUrl struct {
	Data      Filter  `json:"data,omitempty"`
	Url       *string `json:"url,omitempty"`
	Whitelist *bool   `json:"whitelist,omitempty"`
}

// Filtering settings
type FilterStatus struct {
	Enabled   *bool     `json:"enabled,omitempty"`
	Filters   *[]Filter `json:"filters,omitempty"`
	Interval  *int      `json:"interval,omitempty"`
	UserRules *[]string `json:"user_rules,omitempty"`
}

// /version.json request data
type GetVersionRequest struct {
	// If false, server will check for a new version data only once in several hours.
	RecheckNow *bool `json:"recheck_now,omitempty"`
}

// AdGuard Home initial configuration for the first-install wizard.
type InitialConfiguration struct {
	// Port information
	Dns AddressInfo `json:"dns"`

	// Basic auth password
	Password string `json:"password"`

	// Basic auth username
	Username string `json:"username"`

	// Port information
	Web AddressInfo `json:"web"`
}

// AdGuard Home initial configuration for the first-install wizard.
type InitialConfigurationBeta struct {
	// Port information
	Dns AddressInfoBeta `json:"dns"`

	// Basic auth password
	Password string `json:"password"`

	// Basic auth username
	Username string `json:"username"`

	// Port information
	Web AddressInfoBeta `json:"web"`
}

// Login request data
type Login struct {
	// User name
	Name *string `json:"name,omitempty"`

	// Password
	Password *string `json:"password,omitempty"`
}

// Network interface info
type NetInterface struct {
	// Flags could be any combination of the following values, divided by the "|" character: "up", "broadcast", "loopback", "pointtopoint" and "multicast".
	Flags           string    `json:"flags"`
	HardwareAddress string    `json:"hardware_address"`
	IpAddresses     *[]string `json:"ip_addresses,omitempty"`
	Mtu             int       `json:"mtu"`
	Name            string    `json:"name"`
}

// Network interfaces dictionary, keys are interface names.
type NetInterfaces struct {
	AdditionalProperties map[string]NetInterface `json:"-"`
}

// Information about the current user
type ProfileInfo struct {
	Name *string `json:"name,omitempty"`
}

// Query log
type QueryLog struct {
	Data   *[]QueryLogItem `json:"data,omitempty"`
	Oldest *string         `json:"oldest,omitempty"`
}

// Query log configuration
type QueryLogConfig struct {
	// Anonymize clients' IP addresses
	AnonymizeClientIp *bool `json:"anonymize_client_ip,omitempty"`

	// Is query log enabled
	Enabled *bool `json:"enabled,omitempty"`

	// Time period for query log rotation.
	Interval *QueryLogConfigInterval `json:"interval,omitempty"`
}

// Time period for query log rotation.
type QueryLogConfigInterval float32

// Query log item
type QueryLogItem struct {
	Answer *[]DnsAnswer `json:"answer,omitempty"`

	// If true, the response had the Authenticated Data (AD) flag set.
	AnswerDnssec *bool `json:"answer_dnssec,omitempty"`

	// Defines if the response has been served from cache.
	Cached *bool `json:"cached,omitempty"`

	// The client's IP address.
	Client *string `json:"client,omitempty"`

	// The ClientID, if provided in DoH, DoQ, or DoT.
	ClientId *string `json:"client_id,omitempty"`

	// Client information for a query log item.
	ClientInfo  *QueryLogItemClient `json:"client_info,omitempty"`
	ClientProto *interface{}        `json:"client_proto,omitempty"`
	ElapsedMs   *string             `json:"elapsedMs,omitempty"`

	// In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	// Deprecated: use `rules[*].filter_list_id` instead.
	FilterId *int `json:"filterId,omitempty"`

	// Answer from upstream server (optional)
	OriginalAnswer *[]DnsAnswer `json:"original_answer,omitempty"`

	// DNS question section
	Question *DnsQuestion `json:"question,omitempty"`

	// Request filtering status.
	Reason *QueryLogItemReason `json:"reason,omitempty"`

	// Filtering rule applied to the request (if any).
	// Deprecated: use `rules[*].text` instead.
	Rule *string `json:"rule,omitempty"`

	// Applied rules.
	Rules *[]ResultRule `json:"rules,omitempty"`

	// Set if reason=FilteredBlockedService
	ServiceName *string `json:"service_name,omitempty"`

	// DNS response status
	Status *string `json:"status,omitempty"`

	// DNS request processing start time
	Time *string `json:"time,omitempty"`

	// Upstream URL starting with tcp://, tls://, https://, or with an IP address.
	Upstream *string `json:"upstream,omitempty"`
}

// Request filtering status.
type QueryLogItemReason string

// Client information for a query log item.
type QueryLogItemClient struct {
	// Whether the client's IP is blocked or not.
	Disallowed bool `json:"disallowed"`

	// The rule due to which the client is allowed or blocked.
	DisallowedRule string `json:"disallowed_rule"`

	// Persistent client's name or runtime client's hostname.  May be empty.
	Name string `json:"name"`

	// Client WHOIS information, if any.
	Whois QueryLogItemClientWhois `json:"whois"`
}

// Client WHOIS information, if any.
type QueryLogItemClientWhois struct {
	// City, if any.
	City *string `json:"city,omitempty"`

	// Country, if any.
	Country *string `json:"country,omitempty"`

	// Organization name, if any.
	Orgname *string `json:"orgname,omitempty"`
}

// /remove_url request data
type RemoveUrlRequest struct {
	// Previously added URL containing filtering rules
	Url *string `json:"url,omitempty"`
}

// Applied rule.
type ResultRule struct {
	// In case if there's a rule applied to this DNS request, this is ID of the filter list that the rule belongs to.
	FilterListId *int64 `json:"filter_list_id,omitempty"`

	// The text of the filtering rule applied to the request (if any).
	Text *string `json:"text,omitempty"`
}

// Rewrite rule
type RewriteEntry struct {
	// value of A, AAAA or CNAME DNS record
	Answer *string `json:"answer,omitempty"`

	// Domain name
	Domain *string `json:"domain,omitempty"`
}

// Rewrite rules array
type RewriteList []RewriteEntry

// AdGuard Home server status and configuration
type ServerStatus struct {
	DhcpAvailable     *bool    `json:"dhcp_available,omitempty"`
	DnsAddresses      []string `json:"dns_addresses"`
	DnsPort           uint16   `json:"dns_port"`
	HttpPort          uint16   `json:"http_port"`
	Language          string   `json:"language"`
	ProtectionEnabled bool     `json:"protection_enabled"`
	Running           bool     `json:"running"`
	Version           string   `json:"version"`
}

// Server statistics data
type Stats struct {
	// Average time in milliseconds on processing a DNS
	AvgProcessingTime *float32 `json:"avg_processing_time,omitempty"`
	BlockedFiltering  *[]int   `json:"blocked_filtering,omitempty"`
	DnsQueries        *[]int   `json:"dns_queries,omitempty"`

	// Number of requests blocked by filtering rules
	NumBlockedFiltering *int `json:"num_blocked_filtering,omitempty"`

	// Total number of DNS queries
	NumDnsQueries *int `json:"num_dns_queries,omitempty"`

	// Number of blocked adult websites
	NumReplacedParental *int `json:"num_replaced_parental,omitempty"`

	// Number of requests blocked by safebrowsing module
	NumReplacedSafebrowsing *int `json:"num_replaced_safebrowsing,omitempty"`

	// Number of requests blocked by safesearch module
	NumReplacedSafesearch *int   `json:"num_replaced_safesearch,omitempty"`
	ReplacedParental      *[]int `json:"replaced_parental,omitempty"`
	ReplacedSafebrowsing  *[]int `json:"replaced_safebrowsing,omitempty"`

	// Time units
	TimeUnits         *StatsTimeUnits  `json:"time_units,omitempty"`
	TopBlockedDomains *[]TopArrayEntry `json:"top_blocked_domains,omitempty"`
	TopClients        *[]TopArrayEntry `json:"top_clients,omitempty"`
	TopQueriedDomains *[]TopArrayEntry `json:"top_queried_domains,omitempty"`
}

// Time units
type StatsTimeUnits string

// Statistics configuration
type StatsConfig struct {
	// Time period to keep the data.  `0` means that the statistics is disabled.
	Interval *StatsConfigInterval `json:"interval,omitempty"`
}

// Time period to keep the data.  `0` means that the statistics is disabled.
type StatsConfigInterval int

// TLS configuration settings and status
type TlsConfig struct {
	// Base64 string with PEM-encoded certificates chain
	CertificateChain *string `json:"certificate_chain,omitempty"`

	// Path to certificate file
	CertificatePath *string `json:"certificate_path,omitempty"`

	// The value of SubjectAltNames field of the first certificate in the chain.
	DnsNames *[]string `json:"dns_names,omitempty"`

	// enabled is the encryption (DoT/DoH/HTTPS) status
	Enabled *bool `json:"enabled,omitempty"`

	// if true, forces HTTP->HTTPS redirect
	ForceHttps *bool `json:"force_https,omitempty"`

	// The issuer of the first certificate in the chain.
	Issuer *string `json:"issuer,omitempty"`

	// Key type.
	KeyType *TlsConfigKeyType `json:"key_type,omitempty"`

	// The NotAfter field of the first certificate in the chain.
	NotAfter *string `json:"not_after,omitempty"`

	// The NotBefore field of the first certificate in the chain.
	NotBefore *string `json:"not_before,omitempty"`

	// DNS-over-QUIC port. If 0, DoQ will be disabled.
	PortDnsOverQuic *uint16 `json:"port_dns_over_quic,omitempty"`

	// DNS-over-TLS port. If 0, DoT will be disabled.
	PortDnsOverTls *uint16 `json:"port_dns_over_tls,omitempty"`

	// HTTPS port. If 0, HTTPS will be disabled.
	PortHttps *uint16 `json:"port_https,omitempty"`

	// Base64 string with PEM-encoded private key
	PrivateKey *string `json:"private_key,omitempty"`

	// Path to private key file
	PrivateKeyPath *string `json:"private_key_path,omitempty"`

	// Set to true if the user has previously saved a private key as a string.  This is used so that the server and the client don't have to send the private key between each other every time, which might lead to security issues.
	PrivateKeySaved *bool `json:"private_key_saved,omitempty"`

	// server_name is the hostname of your HTTPS/TLS server
	ServerName *string `json:"server_name,omitempty"`

	// The subject of the first certificate in the chain.
	Subject *string `json:"subject,omitempty"`

	// Set to true if the specified certificates chain is a valid chain of X509 certificates.
	ValidCert *bool `json:"valid_cert,omitempty"`

	// Set to true if the specified certificates chain is verified and issued by a known CA.
	ValidChain *bool `json:"valid_chain,omitempty"`

	// Set to true if the key is a valid private key.
	ValidKey *bool `json:"valid_key,omitempty"`

	// Set to true if both certificate and private key are correct.
	ValidPair *bool `json:"valid_pair,omitempty"`

	// A validation warning message with the issue description.
	WarningValidation *string `json:"warning_validation,omitempty"`
}

// Key type.
type TlsConfigKeyType string

// Represent the number of hits per key (domain or client IP).
type TopArrayEntry struct {
	DomainOrIp           *int           `json:"domain_or_ip,omitempty"`
	AdditionalProperties map[string]int `json:"-"`
}

// Upstreams configuration
type UpstreamsConfig struct {
	// Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
	BootstrapDns []string `json:"bootstrap_dns"`

	// Local PTR resolvers, port is optional after colon.  Empty value will reset it to default values.
	PrivateUpstream *[]string `json:"private_upstream,omitempty"`

	// Upstream servers, port is optional after colon.  Empty value will reset it to default values.
	UpstreamDns []string `json:"upstream_dns"`
}

// Upstreams configuration response
type UpstreamsConfigResponse struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Information about the latest available version of AdGuard Home.
type VersionInfo struct {
	Announcement    *string `json:"announcement,omitempty"`
	AnnouncementUrl *string `json:"announcement_url,omitempty"`
	CanAutoupdate   *bool   `json:"can_autoupdate,omitempty"`

	// If true then other fields doesn't appear.
	Disabled   bool    `json:"disabled"`
	NewVersion *string `json:"new_version,omitempty"`
}

// WhoisInfo defines model for WhoisInfo.
type WhoisInfo struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AccessSetJSONBody defines parameters for AccessSet.
type AccessSetJSONBody AccessSetRequest

// MobileConfigDoHParams defines parameters for MobileConfigDoH.
type MobileConfigDoHParams struct {
	// Host for which the config is generated.  If no host is provided, `tls.server_name` from the configuration file is used.  If `tls.server_name` is not set, the API returns an error with a 500 status.
	Host string `json:"host"`

	// ClientID.
	ClientId *string `json:"client_id,omitempty"`
}

// MobileConfigDoTParams defines parameters for MobileConfigDoT.
type MobileConfigDoTParams struct {
	// Host for which the config is generated.  If no host is provided, `tls.server_name` from the configuration file is used.  If `tls.server_name` is not set, the API returns an error with a 500 status.
	Host string `json:"host"`

	// ClientID.
	ClientId *string `json:"client_id,omitempty"`
}

// BlockedServicesSetJSONBody defines parameters for BlockedServicesSet.
type BlockedServicesSetJSONBody BlockedServicesArray

// ClientsAddJSONBody defines parameters for ClientsAdd.
type ClientsAddJSONBody Client

// ClientsDeleteJSONBody defines parameters for ClientsDelete.
type ClientsDeleteJSONBody ClientDelete

// ClientsFindParams defines parameters for ClientsFind.
type ClientsFindParams struct {
	// Filter by IP address or ClientIDs.  Parameters with names `ip1`, `ip2`, and so on are also accepted and interpreted as "ip0 OR ip1 OR ip2".
	// TODO(a.garipov): Replace with a better query API.
	Ip0 *string `json:"ip0,omitempty"`
}

// ClientsUpdateJSONBody defines parameters for ClientsUpdate.
type ClientsUpdateJSONBody ClientUpdate

// DhcpSetConfigJSONBody defines parameters for DhcpSetConfig.
type DhcpSetConfigJSONBody DhcpConfig

// DnsConfigJSONBody defines parameters for DnsConfig.
type DnsConfigJSONBody DNSConfig

// FilteringAddURLJSONBody defines parameters for FilteringAddURL.
type FilteringAddURLJSONBody AddUrlRequest

// FilteringCheckHostParams defines parameters for FilteringCheckHost.
type FilteringCheckHostParams struct {
	// Filter by host name
	Name *string `json:"name,omitempty"`
}

// FilteringConfigJSONBody defines parameters for FilteringConfig.
type FilteringConfigJSONBody FilterConfig

// FilteringRefreshJSONBody defines parameters for FilteringRefresh.
type FilteringRefreshJSONBody FilterRefreshRequest

// FilteringRemoveURLJSONBody defines parameters for FilteringRemoveURL.
type FilteringRemoveURLJSONBody RemoveUrlRequest

// FilteringSetURLJSONBody defines parameters for FilteringSetURL.
type FilteringSetURLJSONBody FilterSetUrl

// InstallCheckConfigJSONBody defines parameters for InstallCheckConfig.
type InstallCheckConfigJSONBody CheckConfigRequest

// InstallCheckConfigBetaJSONBody defines parameters for InstallCheckConfigBeta.
type InstallCheckConfigBetaJSONBody CheckConfigRequestBeta

// InstallConfigureJSONBody defines parameters for InstallConfigure.
type InstallConfigureJSONBody InitialConfiguration

// InstallConfigureBetaJSONBody defines parameters for InstallConfigureBeta.
type InstallConfigureBetaJSONBody InitialConfigurationBeta

// LoginJSONBody defines parameters for Login.
type LoginJSONBody Login

// QueryLogParams defines parameters for QueryLog.
type QueryLogParams struct {
	// Filter by older than
	OlderThan *string `json:"older_than,omitempty"`

	// Specify the ranking number of the first item on the page.  Even though it is possible to use "offset" and "older_than", we recommend choosing one of them and sticking to it.
	Offset *int `json:"offset,omitempty"`

	// Limit the number of records to be returned
	Limit *int `json:"limit,omitempty"`

	// Filter by domain name or client IP
	Search *string `json:"search,omitempty"`

	// Filter by response status
	ResponseStatus *QueryLogParamsResponseStatus `json:"response_status,omitempty"`
}

// QueryLogParamsResponseStatus defines parameters for QueryLog.
type QueryLogParamsResponseStatus string

// QueryLogConfigJSONBody defines parameters for QueryLogConfig.
type QueryLogConfigJSONBody QueryLogConfig

// StatsConfigJSONBody defines parameters for StatsConfig.
type StatsConfigJSONBody StatsConfig

// TestUpstreamDNSJSONBody defines parameters for TestUpstreamDNS.
type TestUpstreamDNSJSONBody UpstreamsConfig

// GetVersionJsonJSONBody defines parameters for GetVersionJson.
type GetVersionJsonJSONBody GetVersionRequest

// AccessSetJSONRequestBody defines body for AccessSet for application/json ContentType.
type AccessSetJSONRequestBody AccessSetJSONBody

// BlockedServicesSetJSONRequestBody defines body for BlockedServicesSet for application/json ContentType.
type BlockedServicesSetJSONRequestBody BlockedServicesSetJSONBody

// ClientsAddJSONRequestBody defines body for ClientsAdd for application/json ContentType.
type ClientsAddJSONRequestBody ClientsAddJSONBody

// ClientsDeleteJSONRequestBody defines body for ClientsDelete for application/json ContentType.
type ClientsDeleteJSONRequestBody ClientsDeleteJSONBody

// ClientsUpdateJSONRequestBody defines body for ClientsUpdate for application/json ContentType.
type ClientsUpdateJSONRequestBody ClientsUpdateJSONBody

// DhcpAddStaticLeaseJSONRequestBody defines body for DhcpAddStaticLease for application/json ContentType.
type DhcpAddStaticLeaseJSONRequestBody DhcpStaticLease

// DhcpRemoveStaticLeaseJSONRequestBody defines body for DhcpRemoveStaticLease for application/json ContentType.
type DhcpRemoveStaticLeaseJSONRequestBody DhcpStaticLease

// DhcpSetConfigJSONRequestBody defines body for DhcpSetConfig for application/json ContentType.
type DhcpSetConfigJSONRequestBody DhcpSetConfigJSONBody

// DnsConfigJSONRequestBody defines body for DnsConfig for application/json ContentType.
type DnsConfigJSONRequestBody DnsConfigJSONBody

// FilteringAddURLJSONRequestBody defines body for FilteringAddURL for application/json ContentType.
type FilteringAddURLJSONRequestBody FilteringAddURLJSONBody

// FilteringConfigJSONRequestBody defines body for FilteringConfig for application/json ContentType.
type FilteringConfigJSONRequestBody FilteringConfigJSONBody

// FilteringRefreshJSONRequestBody defines body for FilteringRefresh for application/json ContentType.
type FilteringRefreshJSONRequestBody FilteringRefreshJSONBody

// FilteringRemoveURLJSONRequestBody defines body for FilteringRemoveURL for application/json ContentType.
type FilteringRemoveURLJSONRequestBody FilteringRemoveURLJSONBody

// FilteringSetURLJSONRequestBody defines body for FilteringSetURL for application/json ContentType.
type FilteringSetURLJSONRequestBody FilteringSetURLJSONBody

// InstallCheckConfigJSONRequestBody defines body for InstallCheckConfig for application/json ContentType.
type InstallCheckConfigJSONRequestBody InstallCheckConfigJSONBody

// InstallCheckConfigBetaJSONRequestBody defines body for InstallCheckConfigBeta for application/json ContentType.
type InstallCheckConfigBetaJSONRequestBody InstallCheckConfigBetaJSONBody

// InstallConfigureJSONRequestBody defines body for InstallConfigure for application/json ContentType.
type InstallConfigureJSONRequestBody InstallConfigureJSONBody

// InstallConfigureBetaJSONRequestBody defines body for InstallConfigureBeta for application/json ContentType.
type InstallConfigureBetaJSONRequestBody InstallConfigureBetaJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// QueryLogConfigJSONRequestBody defines body for QueryLogConfig for application/json ContentType.
type QueryLogConfigJSONRequestBody QueryLogConfigJSONBody

// RewriteAddJSONRequestBody defines body for RewriteAdd for application/json ContentType.
type RewriteAddJSONRequestBody RewriteEntry

// RewriteDeleteJSONRequestBody defines body for RewriteDelete for application/json ContentType.
type RewriteDeleteJSONRequestBody RewriteEntry

// StatsConfigJSONRequestBody defines body for StatsConfig for application/json ContentType.
type StatsConfigJSONRequestBody StatsConfigJSONBody

// TestUpstreamDNSJSONRequestBody defines body for TestUpstreamDNS for application/json ContentType.
type TestUpstreamDNSJSONRequestBody TestUpstreamDNSJSONBody

// TlsConfigureJSONRequestBody defines body for TlsConfigure for application/json ContentType.
type TlsConfigureJSONRequestBody TlsConfig

// TlsValidateJSONRequestBody defines body for TlsValidate for application/json ContentType.
type TlsValidateJSONRequestBody TlsConfig

// GetVersionJsonJSONRequestBody defines body for GetVersionJson for application/json ContentType.
type GetVersionJsonJSONRequestBody GetVersionJsonJSONBody

// Getter for additional properties for ClientsFindEntry. Returns the specified
// element and whether it was found
func (a ClientsFindEntry) Get(fieldName string) (value ClientFindSubEntry, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ClientsFindEntry
func (a *ClientsFindEntry) Set(fieldName string, value ClientFindSubEntry) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]ClientFindSubEntry)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ClientsFindEntry to handle AdditionalProperties
func (a *ClientsFindEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]ClientFindSubEntry)
		for fieldName, fieldBuf := range object {
			var fieldVal ClientFindSubEntry
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ClientsFindEntry to handle AdditionalProperties
func (a ClientsFindEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NetInterfaces. Returns the specified
// element and whether it was found
func (a NetInterfaces) Get(fieldName string) (value NetInterface, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NetInterfaces
func (a *NetInterfaces) Set(fieldName string, value NetInterface) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]NetInterface)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NetInterfaces to handle AdditionalProperties
func (a *NetInterfaces) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]NetInterface)
		for fieldName, fieldBuf := range object {
			var fieldVal NetInterface
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NetInterfaces to handle AdditionalProperties
func (a NetInterfaces) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TopArrayEntry. Returns the specified
// element and whether it was found
func (a TopArrayEntry) Get(fieldName string) (value int, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TopArrayEntry
func (a *TopArrayEntry) Set(fieldName string, value int) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]int)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TopArrayEntry to handle AdditionalProperties
func (a *TopArrayEntry) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["domain_or_ip"]; found {
		err = json.Unmarshal(raw, &a.DomainOrIp)
		if err != nil {
			return fmt.Errorf("error reading 'domain_or_ip': %w", err)
		}
		delete(object, "domain_or_ip")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]int)
		for fieldName, fieldBuf := range object {
			var fieldVal int
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TopArrayEntry to handle AdditionalProperties
func (a TopArrayEntry) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DomainOrIp != nil {
		object["domain_or_ip"], err = json.Marshal(a.DomainOrIp)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'domain_or_ip': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpstreamsConfigResponse. Returns the specified
// element and whether it was found
func (a UpstreamsConfigResponse) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpstreamsConfigResponse
func (a *UpstreamsConfigResponse) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpstreamsConfigResponse to handle AdditionalProperties
func (a *UpstreamsConfigResponse) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpstreamsConfigResponse to handle AdditionalProperties
func (a UpstreamsConfigResponse) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for WhoisInfo. Returns the specified
// element and whether it was found
func (a WhoisInfo) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for WhoisInfo
func (a *WhoisInfo) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for WhoisInfo to handle AdditionalProperties
func (a *WhoisInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for WhoisInfo to handle AdditionalProperties
func (a WhoisInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
